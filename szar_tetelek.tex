\documentclass[a4paper]{article}
\usepackage{t1enc}
\usepackage[magyar]{babel}
\usepackage[utf8]{inputenc}
\usepackage{times}
\usepackage{fullpage}
\usepackage{enumitem}
\usepackage{graphicx}
\title{Számítógép-architektúrák -- kidolgozott tételsor}
\author{Balázs Botond}
\begin{document}
\maketitle

\section{Előadás}

\subsection{Digitális számítógép. Strukturált számítógép-felépítés. Nyelvek, szintek, virtuális gépek. Korszerű többszintű számítógépek.}

\subsubsection{Digitális számítógép}

A \emph{digitális számítógép} problémákat old meg a neki adott utasítások végrehajtása által. A \textit{program} olyan utasítássorozat, mely megadja az adott problémát megoldó algoritmust.A számítógép digitális áramkörei egyszerű utasítások korlátozott halmazát ismerik fel és hajtják végre. Minden programot ilyen utasításokká kell konvertálni végrehajtás előtt.

\textit{Gépi nyelv:} az ilyen utasítások összessége, ennek segítségével kommunikálhatunk a számítógéppel.

\begin{itemize}
	\item Elemi utasításokból áll
	\item Elektronikus áramkörökkel valósítják meg
	\item Kompromisszum az ár és a bonyolultság között
	\item A felhasználók számára nehézkes, bonyolult használat
\end{itemize}

\subsubsection{Strukturált számítógép-felépítés; nyelvek, szintek, virtuális gépek}

A bonyolultságot egymásra épülő absztrakciós szintekkel próbáljuk kezelni. Nevezzük a számítógép áramkörei által értelmezett gépi nyelvet $L_0$-nak, és vegyünk egy magasabb szintű, a felhasználó számára kényelmesebb $L_1$ nyelvet. Az $L_1$ nyelven írt programok végrehajtására ekkor két stratégiát használhatunk:

\begin{enumerate}
	\item \textbf{Fordítás}
		\begin{itemize}
			\item A \emph{fordító} végzi
			\item $L_1$ nyelvű program minden utasítását ekvivalens $L_0$ utasításokkal helyettesítjük
			\item A létrejött, tisztán $L_0$ nyelvű programot hajtja végre a számítógép, $L_1$-et eldobjuk			
		\end{itemize}
	\item \textbf{Értelmezés}
		\begin{itemize}
			\item Az \emph{értelmező} végzi
			\item A számítógépet az $L_0$ nyelven megírt értelmező vezérli az $L_1$ nyelvű program alapján
			\item Az értelmező bemenete az $L_1$ nyelvű program, minden utasítást elemez, majd azonnal végrehajt
		\end{itemize}
\end{enumerate}

Nevezzük a valódi, $L_0$ nyelvet értelmezni képes számítógépet $M_0$-nak. Az $L_1$ nyelv pedig egy $M_1$ \emph{virtuális gép} nyelvének tekinthető. Elképzelhető az $M_1$-re és az $L_1$ re épülő $M_2$ virtuális gép és $L_2$ nyelv is. Az ilyen, egymásra épülő absztrakciókat alkalmazó módszert hívjuk \emph{strukturált számítógép-felépítésnek}. Fontos megjegyezni, hogy bármely virtuális gép is megépíthető lenne fizikailag, de nagyon drága és bonyolult lenne.

$$M_0(L_0) \leftarrow M_1(L_1) \leftarrow M_2(L_2) \leftarrow ... \leftarrow M_n(L_n)$$

\subsubsection{Korszerű többszintű számítógépek}
\paragraph{-1. Eszközszint}
	A számítógép áramkörei; elektronikai tervezés eredménye.

\paragraph{0. Digitális logika}
\begin{itemize}
	\item Analóg alkaltrészekből (pl. tranzisztor) álló logikai kapuk
	\item Egy vagy több bemeneten 0 vagy 1 értéket kap
	\item Kimenete egyszerű logikai függvények eredménye (ÉS, VAGY, stb.)
	\item Egybites memória állítható össze belőlük
\end{itemize}

\paragraph{1. Mikroarchitektúra}
\begin{itemize}
	\item ALU (Aritmetikai-logikai egység): 8-32 elemű regiszterkészlete van, egyszerű matematikai műveleteket valósít meg
	\item Adatút: regiszter kiválasztása $\rightarrow$ művelet elvégzése $\rightarrow$ eredmény tárolása
	\item Mikroprogram vezérli, közvetlenül a hardver hajtja végre a műveleteket
\end{itemize}

\paragraph{2. Utasításrendszer-architektúra (ISA, Instruction Set Architecture)}
\begin{itemize}
	\item Az utasításkészlet processzorgyártó által kiadott referenciakönyve definiálja
	\item Mikroprogram interpretálja, vagy közvetlenül a hardver hajtja végre
\end{itemize}

\paragraph{3. Operációs rendszer gépi szintje}
\begin{itemize}
	\item A legtöbb ISA-utasítás megmarad (párat esetleg letilt)
	\item Új, interpretált utasítások
	\item Más memóriaszervezés
	\item Esetleg többfeladatosság, többfelhasználós működés
\end{itemize}

\paragraph{4. Assembly nyelv}
\begin{itemize}
	\item Az 1-3 szintek nyelveinek olvasható formája (általában a 3.)
	\item Fordítás a célszintre, majd interpretálás az adott szinten
\end{itemize}

\paragraph{5. Problémaorientált nyelv}
\begin{itemize}
	\item Magas szintű nyelvek (C, C++, Java, Python, stb.)
	\item \textbf{Fordítóprogram} a 3. vagy 4. szintre fordítja, majd az eredmény értelmeződik, vagy
	\item \textbf{Értelmező} hajtja végre
\end{itemize}

Egy szint \textbf{architektúráját} az általa biztosított \emph{adattípusok}, \emph{műveletek}, \emph{szolgáltatások} határozzák meg. Előbbiek az adott szint felhasználója által látható dolgok (interfész). Az ilyen interfészek tervezése a \emph{számítógép-architektúra}, bár a kifejezést számítógépek építésére is használják.

\subsection{A többszintű számítógépek fejlődése. A mikroprogramozás feltalálása. Az operációs rendszer feltalálása. Szolgáltatások átterelése a mikroprogram szintjére. Mikroprogramok száműzése.}

\subsubsection{Többszintű számítógépek fejlődése}

A \emph{hardver} a számítógép áramköreit, memóriáját és bemeneti/kimeneti (B/K, I/O) eszközeit jelenti. A \emph{szoftver} az algoritmusok számítógépes leképezése (program). A hardver és a szoftver \emph{logikailag ekvivalens}: bármilyen szoftver elméletileg megépíthető hardveresen, és bármilyen hardver emulálható szoftveresen.

\subsubsection{A mikroprogramozás feltalálása}

Az 1940-es évek számítógépei kétszintűek (ISA, digitális logika) voltak. Az ilyen gépek bonyolultak, nehezen érthetők és megépíthetők, áramköreik megbízhatatlanok.

1951-ben \emph{Maurice Wilkes} háromszintű architektúrát javasol, ez drasztikusan leegyszerűsíti és megbízhatóbbá teszi a hardvert. Az ISA-szintű programot egy beépített értelmező, a \emph{mikroprogram} hajtja végre. A hardver által támogatott utasításkészlet így jelentősen lecsökkenhet.

Az 1970-es évekre a mikroprogramozás elve uralkodóvá vált.

\subsubsection{Az operációs rendszer feltalálása}

A számítógépeket eleinte maguk a programozók kezelték -- ők készítették és töltötték be a lyukkártyákat, stb. Ez gyakori várakozáshoz és álláshoz vezetett.

1960-ban a gépkezelési feladatok automatizálására létrejött az első \emph{operációs rendszer}, az FMS (Fortran Monitor System). Ez három kezdetleges rendszerhívást (\texttt{*JOB}, \texttt{*FORTRAN}, \texttt{*DATA}) tartalmazott, mely az operációs rendszer gépi szintje kezdeményének tekinthető. Később az úgynevezett \emph{kötegelt rendszerek} bemenetüket lyukkártyáról olvasták, kimenetüket sornyomtatóra írták. Az \emph{időosztásos} rendszerek többfeladatos, többfelhasználós rendszerek voltak, melyeket távoli terminálokról, telefonon keresztül is el lehetett érni.

\subsubsection{Szolgáltatások átterelése a mikroprogram szintjére}

A mikroprogram bővítésével új, kényelmes, de redundáns utasítások jöttek létre. Ilyen volt pl. az \texttt{INC}, amely az \texttt{ADD} speciális esete, ahol az egyik argumentum 1. Ezek kicsit gyorsabbak voltak, mint az általános utasítások.

Példák komplex utasításokra:

\begin{itemize}
	\item Egészosztás
	\item Szorzás
	\item Lebegőpontos aritmetika
	\item Eljáráshívás
	\item Tömbkezelés
	\item Program mozgatása memórián belül
	\item Megszakítások
	\item Program felfüggesztése, másik folytatása
	\item Multimédiás fájlok feldolgozása
\end{itemize}

\subsubsection{A mikroprogramok száműzése}

A mikroprogramok a komplex utasítások elburjánzása miatt nagyok, lassúak lettek. Az utasításkészlet drasztikus csökkentésével és a megmaradó utasítások közvetlen végrehajtásával jelentős teljesítményjavulást lehetett elérni.

\section{Előadás}

\subsection{A Neumann-elvű gép főbb részei. Központi memória: felépítése, felosztása, mérete.}

\subsubsection{A Neumann-elvű gép főbb részei}

\begin{figure}[h]
	\caption{A Neumann-elvű gép sematikus rajza}
	\label{fig:neumann}
	\includegraphics[width=\textwidth]{neumann}
\end{figure}

A \emph{központi memória} a program kódját és adatait tartalmazza számokként tárolva. A \emph{központi feldolgozóegység} a központi memóriában tárolt program utasításait olvassa be és hajtja végre. A \emph{külső sín} a számítógép részegységeit köti össze; adatokat, címeket és vezérlőjeleket továbbít. A \emph{belső sín} a CPU részei közötti kommunikációt teszi lehetővé. A \emph{bemeneti-kimeneti eszközök} segítségével valósul meg a kapcsolat a felhasználóval és az adattárolás (háttértárolón).

Ezen kívül egyéb, a \emph{működést segítő eszközök} tartoznak a számítógéphez, mint például a gépház és a tápegység.

\subsubsection{Központi memória}

\paragraph{Felépítése} A tárolás alapegysége a \emph{bit}, mely 0 vagy 1 értéket vehet fel. Ezt elektronikusan az áram jelenlétével vagy hiányával ábrázolják. Legkisebb címezhető egysége a \emph{rekesz (cella)}, mely egymást követő biteket tartalmaz. Egy rekesz leggyakrabban 8 bites (\emph{bájt}), de korábban ettől eltérő csoportosítással is lehetett találkozni.

A memóriarekeszek tartalmát címük alapján érhetjük el. Egyes gépeken a memóriát egydimenziós tömbnek tekinthetjük, melynek indexei a memóriacímek. Máshol a kis címhossz miatt szegmensekre osztják a memóriát, és a szegmens és egy ennek kezdőpontjához képesti eltolás megadásával címezhetünk meg egy rekeszt (\emph{szegmens:offszet címzés}). Ezeken kívül számos egyéb címzési mód létezik.

A számítógép egy regiszterébe beférő bájtokat \emph{szónak} nevezzük. A szó tehát 32-bites rendszeren 4, 64-bitesen 8 bájtot jelent. Sok gépi kódú utasítás teljes szavakkal dolgozik.A memóriában általában tetszőleges bájtot megcímezhetünk, de a szóhatáron kezdődő címek elérése gyorsabb. A fordítóprogramok általában képesek szóhatárra igazítani az adatokat.

A rekeszek adatokat (pl. egész, lebegőpontos, BCD szám, karakterkód, stb.) vagy gépi kódot tartalmazhatnak. A gépi kódú utasítások és ezek operandusai is számok.

\paragraph{Felosztása} A memória nagy részét a programok szabadon használhatják, bizonyos címterületek azonban a hardverrel való kapcsolattartásra vannak fenntartva. Bizonyos címek meghatározhatják egyes címterületek tartalmát (pl. RAM vagy ROM legyen ott elérhető).

\paragraph{Mérete} Korábban pár kilobájtos, megabájtos volt, ma több gigabájt az általános.

\subsection{Utasítás-végrehajtás. Utasítás- és processzorszintű párhuzamosság. RISC és CISC. Korszerű számítógépek tervezési elvei.}

\subsubsection{Processzorok}

A \emph{CPU} (Central Processing Unit, Központi Feldolgozóegység) feladata a központi memóriában tárolt programok végrehajtása. Ez az utasítások beolvasását, vizsgálatát, majd egyenkénti elvégzését jelenti.

A számítógép komponenseit \emph{sín} (bus) köti össze, ez cím-, adat- és vezérlőjeleket továbbító párhuzamos vezetékek kötege.

A CPU több önálló részegységből áll. A \emph{vezérlőegység} (Control Unit, CU) beolvassa az utasításokat a központi memóriából, és eldönti, hogy milyen típusúak. Az \emph{aritmetikai-logikai egység} (Arithmetic Logic Unit, ALU) az utasítások végrehajtásához szükséges matematikai és logikai műveleteket végzi el.

A CPU-ban kis méretű, nagy sebességű memóriarekeszek, regiszterek is vannak, midegyiknek meghatározott mérete és funkciója van. Általában minden regiszter azonos méretű. A legfontosabb regiszter a \emph{programszámláló} (Program Counter, PC), amely a következő végrehajtandó utasítás memóriacímét tartalmazza. Az \emph{utasításregiszterben} (Instruction Register, IR) pedig az épp végrehajtott utasítást találjuk.

\subsubsection{Utasítás-végrehajtás}

\begin{figure}[h]	
	\centering
		\includegraphics[width=10cm]{adatut}
	\caption{Adatút\label{fig:adatut}}	
\end{figure}

A~\ref{fig:adatut}. ábra az utasítás-végrehajtás úgynevezett \emph{adatciklusát} ábrázolja. Az utasítás (jelen esetben az összeadás) A és B operandusai az általános regiszterekből az ALU bemeneti regisztereibe kerülnek, majd az ALU elvégzi rajtuk a kívánt műveletet. Az eredmény a kimeneti regiszterbe íródik, ahonnan az egyik általános regiszterbe íródik vissza. Az adatok által a ciklusban megtett utat nevezzük \emph{adatútnak}.

A CPU \emph{betöltő-dekódoló-végrehajtó} ciklusának lépései a következők:

\begin{enumerate}
	\item Soron következő utasítás beolvasása a memóriából az utasításregiszterbe
	\item Az utasításszámláló beállítása a következő utasítás címére
	\item A beolvasott utasítás típusának meghatározása
	\item Ha az utasítás a memória egyik szavát használja, helyének megkeresése
	\item Ha szükséges, a memóriaszó beolvasása az egyik CPU-regiszterbe
	\item Az utasítás végrehajtása
	\item Vissza az 1. pontra
\end{enumerate}

A memória elérése lassú, az utasítás és az adatok beolvasása közben a CPU többi része kihasználatlanul marad. Ennek részleges kiküszöbölésére többféle gyorsítási lehetőség kínálkozik:

\begin{itemize}
	\item Órajel frekvenciájának növelése (korlátozott)
	\item Utasításszintű párhuzamosság
		\begin{itemize}
			\item Csővezeték
			\item Szuperskaláris architektúrák
		\end{itemize}
	\item Processzorszintű párhuzamosság
		\begin{itemize}
			\item Tömbszámítógépek
			\item Multiprocesszorok
			\item Multiszámítógépek
		\end{itemize}
\end{itemize}

Mielőtt továbbmennénk, definiálnunk kell két fogalmat. A \emph{késleltetés} egy utasítás végrehajtásának időigényét, a \emph{processzor sávszélessége} (processzor sávszélessége, MIPS, Million Instructions Per Second) pedig azt jelenti, hogy a processzor másodpercenként hánymillió utasítást képes végrehajtani.

\subsubsection{Utasításszintű párhuzamosság}

\begin{figure}[h]	
	\centering
		\includegraphics[width=\textwidth]{csovezetek}
	\caption{Példa csővezetékre\label{fig:csovezetek}}	
\end{figure}

\paragraph{Csővezetékek} A processzorokban már nagyon korán megjelent az \emph{előolvasási puffer} (prefetch buffer), egy olyan regisztercsoport, amibe a gép már az utasítás végrehajtásának vége előtt beolvassa a következő utasítást. Az előolvasás a végrehajtást így két részre osztja: a beolvasásra és magára a végrehajtásra.

A \emph{csővezeték} (pipeline) fogalma ezt a stratégiát fejleszti tovább; az utasítás-végrehajtást it sok (akár 12) részre is felosztják. Minden részlépést párhuzamos működésre képes, dedikált áramkörök hajtanak végre. A~\ref{fig:csovezetek}. ábrán egy ötfázisú csővezeték látható. A végrehajtás fázisai:

\begin{enumerate}
	\item Utasítás beolvasása a memóriából, majd pufferbe helyezése
	\item Utasítás típusának és operandusainak meghatározása
	\item Operandusok megkeresése és beolvasása a regiszterekből vagy a memóriából
	\item Az utasítás végrehajtása (tipikusan az operandusokat az adatúton végighajtva)
	\item Az eredmény beírása a megfelelő regiszterbe
\end{enumerate}

A~\ref{fig:csovezetek_vegrehajtas}. ábra az idő függvényében ábrázolja a csővezeték működését. A csővezetékezés módszere továbbfejleszthető \emph{párhuzamos csővezetékek} alkalmazásával. Ekkor egy közös utasítás-beolvasó egység több, saját ALU-val rendelkező csővezetéket szolgál ki. Ez az elrendezés akkor teszi lehetővé a párhuzamos végrehajtást, ha a csővezetékek nem használnak közös erőforrásokat, és nem függenek egymás eredményétől. Ezt vagy a fordítóprogramnak kell garantálnia, vagy extra hardver detektálja és oldja fel az ütközéseket. Általában 2-4 csővezetéket használnak. A Pentium hasonló megoldást alkalmaz, itt a fő csővezetékbe bármilyen, a másodlagosba csak egész műveleteket végző utasítás kerülhet.

\begin{figure}[h]	
	\centering
		\includegraphics[width=10cm]{csovezetek_vegrehajtas}
	\caption{Csővezeték működése\label{fig:csovezetek_vegrehajtas}}	
\end{figure}

A csővezetékezés kompromisszum a késleltetés és a sávszélesség között. A sávszélesség nő, mert másodpercenként ötször annyi utasítás végrehajtása ér véget, mint egyébként. Viszont a késleltetés is nő, mert egy utasítást sokszor tovább tart végrehajtani.

\paragraph{Szuperskaláris architektúrák} Kettőnél több csővezeték hozzáadása már túl sok és túl bonyolult hardvert igényel, ezért ehelyett egy másik megoldást alkalmaznak. A processzorban csak egy csővezeték van, viszont ez több működési egységgel is rendelkezik, ahogy az a~\ref{fig:szuperskalaris}. ábrán látható. Az ilyen processzorok jellemzője, hogy egy órajelciklus alatt több utasítás végrehajtását is elkezdhetik. A kulcsgondolat tehát, hogy az utasításkiadás sebessége sokkal nagyobb lehet, mint a végrehajtásuké, mert ez utóbbit több részegység párhuzamosan végzi.

\begin{figure}[h]	
	\centering
		\includegraphics[width=\textwidth]{szuperskalaris}
	\caption{Szuperskaláris processzor öt működési egységgel\label{fig:szuperskalaris}}	
\end{figure}

\subsubsection{Processzorszintű párhuzamosság}

\paragraph{Tömbszámítógépek} Ha egy feladat megoldásához eltérő adatokon mindig ugyanazt a műveletet kell elvégezni, ezt a tulajdonságot kihasználhatjuk a megoldás párhuzamosítására. A \emph{tömbprocesszorokban} egyetlen vezérlőegység processzorok tömbjének egyszerre adja ki az utasításokat, melyeket azok a saját memóriájukból beolvasott, eltérő adatokon hajtanak végre. A \emph{vektorprocesszor} ettől abban tér el, hogy az összes összeadási műveletet egyetlen, erősen csővezetékezett összeadó végzi.

\paragraph{Multiprocesszorok} Közös memóriát használnak, ezért a processzorok együttműködése külön vezérlést igényel. A processzoroknak saját memóriája is lehet. Közösen használt sínrendszerük van, mely teljesítmény szempontjából gyakran szűk keresztmetszet. Jellemzően párszáz CPU-ból állnak. Könnyebb programozni, nehezebb megépíteni.

\paragraph{Multiszámítógépek} Nincs közös sínük, a processzorok közötti kommunikáció üzenetküldéssel valósul meg. Általában nincs minden gép összekötve egymással, például fastruktúrába, 2D, 3D rácsba vagy gyűrűbe szervezik őket. Ez azt eredményezi, hogy egy üzenetnek általában több számítógépen is át kell haladnia. Tízezer processzort is gond nélkül összekapcsoltak már ezzel a módszerrel. Nehezebb programozni, könnyebb megépíteni.

\subsubsection{CISC és RISC processzorok}

\paragraph{RISC (Reduced Instruction Set Computer)} Csökkentett utasításkészletű számítógép, csak az adatút egyszeri bejárásával végrehajtható utasításokat ismer. Tipikusan kb. 50 elemű utasításkészlet, jobb teljesítmény.

\paragraph{CISC (Complex Instruction Set Computer)} Összetett utasításkészletű számítógép, a gépi kódú utasításokat mikroprogram interpretálja. Ez az architektúra lassabb végrehajtást eredményez.

Az Intel processzorok eleinte CISC architektúrájúak voltak, később ebbe (a 80486-os típustól kezdve) a leggyakoribb utasítások végrehajtására integráltak egy RISC magot.

\subsubsection{Korszerű számítógépek tervezési elvei}

\begin{itemize}
	\item \emph{Minden utasítást közvetlenül a hardver hajtson végre.} A gyakran használtakat mindenképpen; az interpretált mikroutasításokat kerülni kell.
	\item \emph{Maximalizálni kell az utasítások kiadási ütemét.} Törekedni kell a párhuzamos utasításkiadásra.
	\item \emph{Az utasítások legyenek könnyen dekódolhatók.} Kevés mezőből álljanak, legyenek szabályosak, egyforma hosszúak.
	\item \emph{Csak a betöltő és a tároló utasítások hivatkozzanak a memóriára.} Törekedni kell a párhuzamos utasításkiadásra.
	\item \emph{Sok regiszter legyen.} A számítások során ne kelljen a lassú memóriába írni.
\end{itemize}

\section{Előadás}

\subsection{Számrendszerek, átváltások, egész számok ábrázolása, bináris aritmetika.}

\subsubsection{Számrendszerek}

A tízes számrendszerbeli számok számjegyei mindig a tíz valamely hatványának többszörösét jelentik. Általánosan így írhatunk fel egy tízes számrendszerbeli helyiértékes számot:

$$N = 10^{n} d_n + \dots + 10^3 d_3 + 10^2 d_2 + 10^1 d_1 + 10^0 d_0 + 10^{-1} d_{-1} + 10^{-2} d_{-2} + \dots + 10^{-k} d_{-k}$$

$$N = \sum_{i=-k}^{n} 10^i d_i\quad0 \leq d < 10$$

$N$ itt a szám értékét, $d_{-k} \dots d_n$ a számjegyeket jelenti. A helyiértékes számírás alapszáma a 10-től eltérő is lehet. Ha az alapszámot $b$-nek nevezzük, a számérték:

$$N = \sum_{i=-k}^{n} b^i d_i\quad0 \leq d < b$$

A tízesen kívül az informatikában fontos számrendszer a \emph{kettes (bináris)}, a \emph{nyolcas (oktális)} és a \emph{tizenhatos (hexadecimális)}. A kettes számrendszer számjegyei megfeleltethetők a biteknek, ezért a digitális számítógép binárisan számol. Egy oktális számjegy 3, egy hexadecimális 4 bináris számjegynek felel meg, ezért ezek között nagyon egyszerű az átalakítás. A 9-nél nagyobb hexadecimális számjegyeket növekvő sorrendben az A-F betűkkel jelöljük.

\subsubsection{Átváltások számrendszerek között}

\subsection{Lebegőpontos számok ábrázolása.}

\subsection{Szöveg kódolása. Bájtsorrend. Hibadetektáló és -javító kódok.}

\end{document}